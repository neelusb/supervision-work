# Exercise 39

Since we replace the node to be deleted with its successor, which doesn't have a left subtree, we can guarantee that there are either no subtrees of the node to be deleted's new position, or just one subtree (the right one). If it has no subtrees, this is a valid binary tree already once the node is deleted. If it has just one, we just move the subtree up to take its place and this is once again a valid binary tree. We now have to prove that it is a valid binary search tree specifically.

Let's consider the inorder algorithm of binary trees. It recurses into the left and right children, and puts them together with the root using left :: root :: right. Therefore in a BST starting from the root, since everything in the left child is smaller than it and everything to the right is larger than it, and we put everything to the left before and everything to the right after, and we run this recursively so all the elements will end up in ascending order. Therefore the inorder algorithm run on a BST will always result in a list of the elements sorted into ascending order.

The converse is also true. Say we are told a list in ascending order was made by running the inorder algorithm on a binary tree, we can prove this tree was a BST. Take any element in the list to be the root. Everything to the left in the left is smaller than it, and everything to the right is larger. This is true for every element in the list, so a BST must have made it using inorder.

Swapping two elements in an inorder is the same as swapping them in the actual tree, as you can think of those elements as just being arbitrary indices, and we can just swap the values associated with them. Therefore swapping the node to be deleted with its successor does the same in both the inordered list and the BST. Once we remove the element from the inorder list after that, the list is once again in ascending order, so it must have been made from a BST, so our resulting tree must be a BST.